# 資料合併

## 題目描述

假設有兩組已經排好序的資料，請撰寫一個函數，讀入這兩組資料，並將其合併為一個由大排到小的數值陣列。

### 函式原型

```c
void merge(double A[], int Alen, double B[], int Blen, double C[]);
```

- A 和 B 分別為兩個數值，由大到小排序，長度為 Alen 和 Blen 的陣列。
- C 是一個長度為 Alen + Blen 的陣列，您需要將合併後的結果存入這個陣列，並保持由大到小排序。

### 解題步驟
- 讀取兩組浮點數陣列 A 和 B，並將它們合併成一個新的陣列 C。
- 在合併過程中保持排序，確保最終陣列 C 仍為由大到小排列。
- 函數的 main 程式碼將提供必要的測試資料。

### 完整程式碼

```c
#include <stdio.h>
#define MAXLEN 10

void merge(double A[], int Alen, double B[], int Blen, double C[]) {
    int i = 0, j = 0, k = 0;

    // 合併兩個排序的陣列
    while (i < Alen && j < Blen) {
        if (A[i] > B[j]) {
            C[k++] = A[i++];
        } else {
            C[k++] = B[j++];
        }
    }

    // 把 A 中剩餘的元素加入 C
    while (i < Alen) {
        C[k++] = A[i++];
    }

    // 把 B 中剩餘的元素加入 C
    while (j < Blen) {
        C[k++] = B[j++];
    }
}

int main() {
    double A[MAXLEN], B[MAXLEN], C[2*MAXLEN];
    int lenA, lenB;

    // 讀入兩組資料
    scanf("%d %d", &lenA, &lenB);
    for (int i = 0; i < lenA; i++) {
        scanf("%lf", &A[i]);
    }
    for (int i = 0; i < lenB; i++) {
        scanf("%lf", &B[i]);
    }

    // 合併資料
    merge(A, lenA, B, lenB, C);

    // 輸出結果
    for (int i = 0; i < lenA + lenB; i++) {
        printf("%f\n", C[i]);
    }

    return 0;
}
```

### 輸入範例 1
```text
10 10
10.0 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
20.0 19.0 18.0 17.0 16.0 15.0 14.0 13.0 12.0 11.0
```
### 輸出範例 1
```text
20.000000
19.000000
18.000000
17.000000
16.000000
15.000000
14.000000
13.000000
12.000000
11.000000
10.000000
9.000000
8.000000
7.000000
6.000000
5.000000
4.000000
3.000000
2.000000
1.000000
```

### 輸入範例 2
```text
7 6
2 1 0 -1 -2 -4 -8
-6 -7 -7 -8 -9 -10
```

### 輸出範例 2
```text
2.000000
1.000000
0.000000
-1.000000
-2.000000
-4.000000
-6.000000
-7.000000
-7.000000
-8.000000
-8.000000
-9.000000
-10.000000
```

### 解題思路
- 我們使用兩個指標 i 和 j 來遍歷陣列 A 和 B，依據數字大小將元素逐個放入新的陣列 C 中，並保持排序。
- 如果某個陣列已經遍歷完，則將另一個陣列剩餘的元素直接加入 C。
- 最終，合併後的陣列 C 即為由大到小排序的結果。
